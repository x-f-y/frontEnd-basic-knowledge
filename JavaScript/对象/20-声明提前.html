<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script type="text/javascript">
			/* 
				变量的声明提前(变量提升)
					使用var关键字声明的变量，会在所有代码执行之前被声明(但是不会赋值)
					但是如果声明变量时不使用var关键字，则变量不会被声明提前
				函数的声明提前(函数提升)
					使用函数声明形式创建的函数function 函数名(){}会在所有代码执行之前被创建
						所以我们可以在函数声明前来调用函数
					使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用
			 */

			/* console.log("a = " + a); // a = undefined
			//其实在所有代码执行之前就声明了a，即var a;但当执行到这里时才给a赋值，即a=5;
			var a = 5;
			fun1(); // '我是使用函数声明形式创建的函数'
			//fun1()函数在所有代码执行之前就被创建
			function fun1() {
				console.log("我是使用函数声明形式创建的函数");
			}
			//fun2()函数在所有代码执行之前就被声明，但当代码执行到这一行才被创建
			var fun2 = function() {
				console.log("我是使用函数表达式形式创建的函数");
			};
			fun2(); //不可以在fun2()函数声明前调用 */

			/**
			 * 函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖
			 * 总结：由于函数声明和变量都会提升，如果函数与变量同名，那么只要在变量赋值前打印的都会是函数，在变量赋值之后打印都是变量的值。
			 */

			/* console.log(a) // ƒ a(){}  变量a赋值前打印的都会是函数a
			var a = 1;
			function a() {}
			console.log(a) // 1    变量a赋值后打印的都会是变量a的值 */

			/* //上面的代码就相当于
			function a() {} // 函数提升
			var a // 变量提升
			console.log(a) // 此时变量a只是声明没有赋值所以不会覆盖函数a --> 输出函数a  f a (){}
			a = 1; //变量赋值
			console.log(a) // 此时变量a赋值了 --> 输出变量a的值 1 */

			/* //练习
			console.log(person)//undefined
			console.log(fun)//f fun(){ ... }
			var person = 'jack'
			console.log(person)//jack
			function fun () {
			    console.log(person)
			    var person = 'tom'
			    console.log(person)
			}
			fun()//undefined tom
			console.log(person)//jack */

			/* // 上面的代码就相当于
			function fun() {
				var person
				console.log(person)
				person = 'tom'
				console.log(person)
			}
			var person
			console.log(person) // undefined
			console.log(fun) // f fun() { ... }
			person = 'jack'
			console.log(person) // jack
			fun() // undefined tom
			console.log(person) // jack */
		</script>
	</head>
	<body>
	</body>
</html>
